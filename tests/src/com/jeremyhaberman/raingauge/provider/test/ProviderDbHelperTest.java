package com.jeremyhaberman.raingauge.provider.test;import android.content.ContentValues;import android.content.Context;import android.content.res.Resources;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.test.InstrumentationTestCase;import android.test.RenamingDelegatingContext;import android.test.suitebuilder.annotation.MediumTest;import com.jeremyhaberman.raingauge.provider.ProviderDbHelper;import com.jeremyhaberman.raingauge.provider.RainGaugeProviderContract;public class ProviderDbHelperTest extends InstrumentationTestCase {	public void testProviderDbHelper() {		MyMockContext context = new MyMockContext(getInstrumentation().getTargetContext());		ProviderDbHelper helper = new ProviderDbHelper(context);		assertNotNull(helper);	}	@MediumTest	public void testOnCreate() {		MyMockContext context = new MyMockContext(getInstrumentation().getTargetContext());		ProviderDbHelper helper = new ProviderDbHelper(context);		assertNotNull(helper);		SQLiteDatabase db = helper.getWritableDatabase();		assertNotNull(db);		// test table names		Cursor cursor =				db.query("sqlite_master", new String[]{"name"}, "type='table'", null, null, null,						"name");		String[] expectedTableNames =				new String[]{"android_metadata", "observations", "sqlite_sequence"};		String actualTableName = null;		for (int i = 0; i < expectedTableNames.length; i++) {			cursor.moveToNext();			actualTableName = cursor.getString(0);			assertEquals(expectedTableNames[i], actualTableName);		}		cursor.close();		String where = String.format("tbl_name='%s' AND type='table'",				RainGaugeProviderContract.ObservationsTable.TABLE_NAME);		cursor = db.query("sqlite_master", new String[]{"sql"}, where, null, null, null, null);		assertTrue(cursor.getCount() == 1);		cursor.moveToFirst();		String expectedSql =				"CREATE TABLE observations (_id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp INTEGER, rainfall REAL)";		String actualSql = cursor.getString(0);		assertEquals(expectedSql, actualSql);		cursor.close();		db.close();	}	@MediumTest	public void testOnUpgrade() {		MyMockContext context = new MyMockContext(getInstrumentation().getTargetContext());		/*		 * The current onUpgrade() method drops and recreates the observations table.  For this test,		 * we create the DB at version 1, add a record, open DB version 2 and test that the record		 * no longer exists.		 */		ProviderDbHelper helper = new ProviderDbHelper(context, 1);		SQLiteDatabase db = helper.getWritableDatabase();		Cursor cursor = db.query(RainGaugeProviderContract.ObservationsTable.TABLE_NAME, null, null, null, null, null, null);		assertEquals(0, cursor.getCount());		ContentValues values = new ContentValues();		values.put(RainGaugeProviderContract.ObservationsTable.RAINFALL, 0.5f);		long rowId = db.insert(RainGaugeProviderContract.ObservationsTable.TABLE_NAME, null, values);		assertTrue(rowId != -1);		db.close();		helper.close();		helper = new ProviderDbHelper(context, 2);		db = helper.getReadableDatabase();		cursor = db.query(RainGaugeProviderContract.ObservationsTable.TABLE_NAME, null, null, null, null, null, null);		assertEquals(0, cursor.getCount());		db.close();		helper.close();	}	public class MyMockContext extends RenamingDelegatingContext {		private static final String TAG = "MyMockContext";		private static final String MOCK_FILE_PREFIX = "test.";		public MyMockContext(Context context) {			super(context, MOCK_FILE_PREFIX);		}		@Override		public Resources getResources() {			return super.getResources();		}	}}